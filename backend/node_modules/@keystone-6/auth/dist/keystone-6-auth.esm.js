import _objectWithoutProperties from '@babel/runtime/helpers/esm/objectWithoutProperties';
import _objectSpread from '@babel/runtime/helpers/esm/objectSpread2';
import url from 'url';
import { password, timestamp } from '@keystone-6/core/fields';
import { getGqlNames } from '@keystone-6/core/types';
import { assertInputObjectType, GraphQLInputObjectType, GraphQLString, GraphQLID, parse, validate, assertObjectType } from 'graphql';
import { graphql } from '@keystone-6/core';
import { randomBytes } from 'crypto';

async function validateSecret(secretFieldImpl, identityField, identity, secretField, secret, dbItemAPI) {
  const item = await dbItemAPI.findOne({
    where: {
      [identityField]: identity
    }
  });

  if (!item || !item[secretField]) {
    // See "Identity Protection" in the README as to why this is a thing
    await secretFieldImpl.generateHash('simulated-password-to-counter-timing-attack');
    return {
      success: false
    };
  } else if (await secretFieldImpl.compare(secret, item[secretField])) {
    // Authenticated!
    return {
      success: true,
      item
    };
  } else {
    return {
      success: false
    };
  }
}

function getBaseAuthSchema(_ref) {
  let {
    listKey,
    identityField,
    secretField,
    gqlNames,
    secretFieldImpl,
    base
  } = _ref;
  const ItemAuthenticationWithPasswordSuccess = graphql.object()({
    name: gqlNames.ItemAuthenticationWithPasswordSuccess,
    fields: {
      sessionToken: graphql.field({
        type: graphql.nonNull(graphql.String)
      }),
      item: graphql.field({
        type: graphql.nonNull(base.object(listKey))
      })
    }
  });
  const ItemAuthenticationWithPasswordFailure = graphql.object()({
    name: gqlNames.ItemAuthenticationWithPasswordFailure,
    fields: {
      message: graphql.field({
        type: graphql.nonNull(graphql.String)
      })
    }
  });
  const AuthenticationResult = graphql.union({
    name: gqlNames.ItemAuthenticationWithPasswordResult,
    types: [ItemAuthenticationWithPasswordSuccess, ItemAuthenticationWithPasswordFailure],

    resolveType(val) {
      if ('sessionToken' in val) {
        return gqlNames.ItemAuthenticationWithPasswordSuccess;
      }

      return gqlNames.ItemAuthenticationWithPasswordFailure;
    }

  });
  const extension = {
    query: {
      authenticatedItem: graphql.field({
        type: graphql.union({
          name: 'AuthenticatedItem',
          types: [base.object(listKey)],
          resolveType: (root, context) => {
            var _context$session;

            return (_context$session = context.session) === null || _context$session === void 0 ? void 0 : _context$session.listKey;
          }
        }),

        resolve(root, args, _ref2) {
          let {
            session,
            db
          } = _ref2;

          if (typeof (session === null || session === void 0 ? void 0 : session.itemId) === 'string' && typeof session.listKey === 'string') {
            return db[session.listKey].findOne({
              where: {
                id: session.itemId
              }
            });
          }

          return null;
        }

      })
    },
    mutation: {
      [gqlNames.authenticateItemWithPassword]: graphql.field({
        type: AuthenticationResult,
        args: {
          [identityField]: graphql.arg({
            type: graphql.nonNull(graphql.String)
          }),
          [secretField]: graphql.arg({
            type: graphql.nonNull(graphql.String)
          })
        },

        async resolve(root, _ref3, context) {
          let {
            [identityField]: identity,
            [secretField]: secret
          } = _ref3;

          if (!context.startSession) {
            throw new Error('No session implementation available on context');
          }

          const dbItemAPI = context.sudo().db[listKey];
          const result = await validateSecret(secretFieldImpl, identityField, identity, secretField, secret, dbItemAPI);

          if (!result.success) {
            return {
              code: 'FAILURE',
              message: 'Authentication failed.'
            };
          } // Update system state


          const sessionToken = await context.startSession({
            listKey,
            itemId: result.item.id.toString()
          });
          return {
            sessionToken,
            item: result.item
          };
        }

      })
    }
  };
  return {
    extension,
    ItemAuthenticationWithPasswordSuccess
  };
}

function getInitFirstItemSchema(_ref) {
  let {
    listKey,
    fields,
    itemData,
    gqlNames,
    graphQLSchema,
    ItemAuthenticationWithPasswordSuccess
  } = _ref;
  const createInputConfig = assertInputObjectType(graphQLSchema.getType(`${listKey}CreateInput`)).toConfig();
  const fieldsSet = new Set(fields);
  const initialCreateInput = graphql.wrap.inputObject(new GraphQLInputObjectType(_objectSpread(_objectSpread({}, createInputConfig), {}, {
    fields: Object.fromEntries(Object.entries(createInputConfig.fields).filter(_ref2 => {
      let [fieldKey] = _ref2;
      return fieldsSet.has(fieldKey);
    })),
    name: gqlNames.CreateInitialInput
  })));
  return {
    mutation: {
      [gqlNames.createInitialItem]: graphql.field({
        type: graphql.nonNull(ItemAuthenticationWithPasswordSuccess),
        args: {
          data: graphql.arg({
            type: graphql.nonNull(initialCreateInput)
          })
        },

        async resolve(rootVal, _ref3, context) {
          let {
            data
          } = _ref3;

          if (!context.startSession) {
            throw new Error('No session implementation available on context');
          }

          const dbItemAPI = context.sudo().db[listKey];
          const count = await dbItemAPI.count({});

          if (count !== 0) {
            throw new Error('Initial items can only be created when no items exist in that list');
          } // Update system state
          // this is strictly speaking incorrect. the db API will do GraphQL coercion on a value which has already been coerced
          // (this is also mostly fine, the chance that people are using things where
          // the input value can't round-trip like the Upload scalar here is quite low)


          const item = await dbItemAPI.createOne({
            data: _objectSpread(_objectSpread({}, data), itemData)
          });
          const sessionToken = await context.startSession({
            listKey,
            itemId: item.id.toString()
          });
          return {
            item,
            sessionToken
          };
        }

      })
    }
  };
}

function generateToken(length) {
  return randomBytes(length) // Generates N*8 bits of data
  .toString('base64') // Groups by 6-bits and encodes as ascii chars in [A-Za-z0-9+/] and '=' for padding (~8/6 * N chars)
  .replace(/[^a-zA-Z0-9]/g, '') // Removes any '+', '/' (62, 63) and '=' chars as often require escaping (eg. in urls)
  .slice(0, length); // Shortens the string, so we now have ~6*N bits of data (it's actually log2(62)*N = 5.954*N)
} // TODO: Auth token mutations may leak user identities due to timing attacks :(
// We don't (currently) make any effort to mitigate the time taken to record the new token or sent the email when successful


async function createAuthToken(identityField, identity, dbItemAPI) {
  const item = await dbItemAPI.findOne({
    where: {
      [identityField]: identity
    }
  });

  if (item) {
    return {
      success: true,
      itemId: item.id,
      token: generateToken(20)
    };
  } else {
    return {
      success: false
    };
  }
}

function sanitiseValidForMinsConfig(input) {
  const parsed = Number.parseFloat(input); // > 10 seconds, < 24 hrs, default 10 mins

  return parsed ? Math.max(1 / 6, Math.min(parsed, 60 * 24)) : 10;
}

async function validateAuthToken(listKey, secretFieldImpl, tokenType, identityField, identity, tokenValidMins, token, dbItemAPI) {
  const result = await validateSecret(secretFieldImpl, identityField, identity, `${tokenType}Token`, token, dbItemAPI);

  if (!result.success) {
    // Could be due to:
    // - Missing identity
    // - Missing secret
    // - Secret mismatch.
    return {
      success: false,
      code: 'FAILURE'
    };
  } // Now that we know the identity and token are valid, we can always return 'helpful' errors and stop worrying about protecting identities.


  const {
    item
  } = result;
  const fieldKeys = {
    issuedAt: `${tokenType}IssuedAt`,
    redeemedAt: `${tokenType}RedeemedAt`
  }; // Check that the token has not been redeemed already

  if (item[fieldKeys.redeemedAt]) {
    return {
      success: false,
      code: 'TOKEN_REDEEMED'
    };
  } // Check that the token has not expired


  if (!item[fieldKeys.issuedAt] || typeof item[fieldKeys.issuedAt].getTime !== 'function') {
    throw new Error(`Error redeeming authToken: field ${listKey}.${fieldKeys.issuedAt} isn't a valid Date object.`);
  }

  const elapsedMins = (Date.now() - item[fieldKeys.issuedAt].getTime()) / (1000 * 60);
  const validForMins = sanitiseValidForMinsConfig(tokenValidMins);

  if (elapsedMins > validForMins) {
    return {
      success: false,
      code: 'TOKEN_EXPIRED'
    };
  } // Authenticated!


  return {
    success: true,
    item
  };
}

function getAuthTokenErrorMessage(_ref) {
  let {
    code
  } = _ref;

  switch (code) {
    case 'FAILURE':
      return 'Auth token redemption failed.';

    case 'TOKEN_EXPIRED':
      return 'The auth token provided has expired.';

    case 'TOKEN_REDEEMED':
      return 'Auth tokens are single use and the auth token provided has already been redeemed.';
  }
}

const errorCodes$1 = ['FAILURE', 'TOKEN_EXPIRED', 'TOKEN_REDEEMED'];
const PasswordResetRedemptionErrorCode = graphql.enum({
  name: 'PasswordResetRedemptionErrorCode',
  values: graphql.enumValues(errorCodes$1)
});
function getPasswordResetSchema(_ref) {
  let {
    listKey,
    identityField,
    secretField,
    gqlNames,
    passwordResetLink,
    passwordResetTokenSecretFieldImpl
  } = _ref;

  const getResult = name => graphql.object()({
    name,
    fields: {
      code: graphql.field({
        type: graphql.nonNull(PasswordResetRedemptionErrorCode)
      }),
      message: graphql.field({
        type: graphql.nonNull(graphql.String)
      })
    }
  });

  const ValidateItemPasswordResetTokenResult = getResult(gqlNames.ValidateItemPasswordResetTokenResult);
  const RedeemItemPasswordResetTokenResult = getResult(gqlNames.RedeemItemPasswordResetTokenResult);
  return {
    mutation: {
      [gqlNames.sendItemPasswordResetLink]: graphql.field({
        type: graphql.nonNull(graphql.Boolean),
        args: {
          [identityField]: graphql.arg({
            type: graphql.nonNull(graphql.String)
          })
        },

        async resolve(rootVal, _ref2, context) {
          let {
            [identityField]: identity
          } = _ref2;
          const dbItemAPI = context.sudo().db[listKey];
          const tokenType = 'passwordReset';
          const result = await createAuthToken(identityField, identity, dbItemAPI); // Update system state

          if (result.success) {
            // Save the token and related info back to the item
            const {
              token,
              itemId
            } = result;
            await dbItemAPI.updateOne({
              where: {
                id: `${itemId}`
              },
              data: {
                [`${tokenType}Token`]: token,
                [`${tokenType}IssuedAt`]: new Date().toISOString(),
                [`${tokenType}RedeemedAt`]: null
              }
            });
            await passwordResetLink.sendToken({
              itemId,
              identity,
              token,
              context
            });
          }

          return true;
        }

      }),
      [gqlNames.redeemItemPasswordResetToken]: graphql.field({
        type: RedeemItemPasswordResetTokenResult,
        args: {
          [identityField]: graphql.arg({
            type: graphql.nonNull(graphql.String)
          }),
          token: graphql.arg({
            type: graphql.nonNull(graphql.String)
          }),
          [secretField]: graphql.arg({
            type: graphql.nonNull(graphql.String)
          })
        },

        async resolve(rootVal, _ref3, context) {
          let {
            [identityField]: identity,
            token,
            [secretField]: secret
          } = _ref3;
          const dbItemAPI = context.sudo().db[listKey];
          const tokenType = 'passwordReset';
          const result = await validateAuthToken(listKey, passwordResetTokenSecretFieldImpl, tokenType, identityField, identity, passwordResetLink.tokensValidForMins, token, dbItemAPI);

          if (!result.success) {
            return {
              code: result.code,
              message: getAuthTokenErrorMessage({
                code: result.code
              })
            };
          } // Update system state


          const itemId = result.item.id; // Save the token and related info back to the item

          await dbItemAPI.updateOne({
            where: {
              id: itemId
            },
            data: {
              [`${tokenType}RedeemedAt`]: new Date().toISOString()
            }
          }); // Save the provided secret. Do this as a separate step as password validation
          // may fail, in which case we still want to mark the token as redeemed
          // (NB: Is this *really* what we want? -TL)

          await dbItemAPI.updateOne({
            where: {
              id: itemId
            },
            data: {
              [secretField]: secret
            }
          });
          return null;
        }

      })
    },
    query: {
      [gqlNames.validateItemPasswordResetToken]: graphql.field({
        type: ValidateItemPasswordResetTokenResult,
        args: {
          [identityField]: graphql.arg({
            type: graphql.nonNull(graphql.String)
          }),
          token: graphql.arg({
            type: graphql.nonNull(graphql.String)
          })
        },

        async resolve(rootVal, _ref4, context) {
          let {
            [identityField]: identity,
            token
          } = _ref4;
          const dbItemAPI = context.sudo().db[listKey];
          const tokenType = 'passwordReset';
          const result = await validateAuthToken(listKey, passwordResetTokenSecretFieldImpl, tokenType, identityField, identity, passwordResetLink.tokensValidForMins, token, dbItemAPI);

          if (!result.success) {
            return {
              code: result.code,
              message: getAuthTokenErrorMessage({
                code: result.code
              })
            };
          }

          return null;
        }

      })
    }
  };
}

const errorCodes = ['FAILURE', 'TOKEN_EXPIRED', 'TOKEN_REDEEMED'];
const MagicLinkRedemptionErrorCode = graphql.enum({
  name: 'MagicLinkRedemptionErrorCode',
  values: graphql.enumValues(errorCodes)
});
function getMagicAuthLinkSchema(_ref) {
  let {
    listKey,
    identityField,
    gqlNames,
    magicAuthLink,
    magicAuthTokenSecretFieldImpl,
    base
  } = _ref;
  const RedeemItemMagicAuthTokenFailure = graphql.object()({
    name: gqlNames.RedeemItemMagicAuthTokenFailure,
    fields: {
      code: graphql.field({
        type: graphql.nonNull(MagicLinkRedemptionErrorCode)
      }),
      message: graphql.field({
        type: graphql.nonNull(graphql.String)
      })
    }
  });
  const RedeemItemMagicAuthTokenSuccess = graphql.object()({
    name: gqlNames.RedeemItemMagicAuthTokenSuccess,
    fields: {
      token: graphql.field({
        type: graphql.nonNull(graphql.String)
      }),
      item: graphql.field({
        type: graphql.nonNull(base.object(listKey))
      })
    }
  });
  const RedeemItemMagicAuthTokenResult = graphql.union({
    name: gqlNames.RedeemItemMagicAuthTokenResult,
    types: [RedeemItemMagicAuthTokenSuccess, RedeemItemMagicAuthTokenFailure],

    resolveType(val) {
      return 'token' in val ? gqlNames.RedeemItemMagicAuthTokenSuccess : gqlNames.RedeemItemMagicAuthTokenFailure;
    }

  });
  return {
    mutation: {
      [gqlNames.sendItemMagicAuthLink]: graphql.field({
        type: graphql.nonNull(graphql.Boolean),
        args: {
          [identityField]: graphql.arg({
            type: graphql.nonNull(graphql.String)
          })
        },

        async resolve(rootVal, _ref2, context) {
          let {
            [identityField]: identity
          } = _ref2;
          const dbItemAPI = context.sudo().db[listKey];
          const tokenType = 'magicAuth';
          const result = await createAuthToken(identityField, identity, dbItemAPI); // Update system state

          if (result.success) {
            // Save the token and related info back to the item
            const {
              token,
              itemId
            } = result;
            await dbItemAPI.updateOne({
              where: {
                id: `${itemId}`
              },
              data: {
                [`${tokenType}Token`]: token,
                [`${tokenType}IssuedAt`]: new Date().toISOString(),
                [`${tokenType}RedeemedAt`]: null
              }
            });
            await magicAuthLink.sendToken({
              itemId,
              identity,
              token,
              context
            });
          }

          return true;
        }

      }),
      [gqlNames.redeemItemMagicAuthToken]: graphql.field({
        type: graphql.nonNull(RedeemItemMagicAuthTokenResult),
        args: {
          [identityField]: graphql.arg({
            type: graphql.nonNull(graphql.String)
          }),
          token: graphql.arg({
            type: graphql.nonNull(graphql.String)
          })
        },

        async resolve(rootVal, _ref3, context) {
          let {
            [identityField]: identity,
            token
          } = _ref3;

          if (!context.startSession) {
            throw new Error('No session implementation available on context');
          }

          const dbItemAPI = context.sudo().db[listKey];
          const tokenType = 'magicAuth';
          const result = await validateAuthToken(listKey, magicAuthTokenSecretFieldImpl, tokenType, identityField, identity, magicAuthLink.tokensValidForMins, token, dbItemAPI);

          if (!result.success) {
            return {
              code: result.code,
              message: getAuthTokenErrorMessage({
                code: result.code
              })
            };
          } // Update system state
          // Save the token and related info back to the item


          await dbItemAPI.updateOne({
            where: {
              id: result.item.id
            },
            data: {
              [`${tokenType}RedeemedAt`]: new Date().toISOString()
            }
          });
          const sessionToken = await context.startSession({
            listKey,
            itemId: result.item.id.toString()
          });
          return {
            token: sessionToken,
            item: result.item
          };
        }

      })
    }
  };
}

function assertSecretFieldImpl(impl, listKey, secretField) {
  if (!impl || typeof impl.compare !== 'function' || impl.compare.length < 2 || typeof impl.generateHash !== 'function') {
    const s = JSON.stringify(secretField);
    let msg = `A createAuth() invocation for the "${listKey}" list specifies ${s} as its secretField, but the field type doesn't implement the required functionality.`;
    throw new Error(msg);
  }
}

function getSecretFieldImpl(schema, listKey, fieldKey) {
  var _gqlOutputType$getFie, _gqlOutputType$getFie2;

  const gqlOutputType = assertObjectType(schema.getType(listKey));
  const secretFieldImpl = (_gqlOutputType$getFie = gqlOutputType.getFields()) === null || _gqlOutputType$getFie === void 0 ? void 0 : (_gqlOutputType$getFie2 = _gqlOutputType$getFie[fieldKey].extensions) === null || _gqlOutputType$getFie2 === void 0 ? void 0 : _gqlOutputType$getFie2.keystoneSecretField;
  assertSecretFieldImpl(secretFieldImpl, listKey, fieldKey);
  return secretFieldImpl;
}
const getSchemaExtension = _ref => {
  let {
    identityField,
    listKey,
    secretField,
    gqlNames,
    initFirstItem,
    passwordResetLink,
    magicAuthLink,
    sessionData
  } = _ref;
  return graphql.extend(base => {
    const uniqueWhereInputType = assertInputObjectType(base.schema.getType(`${listKey}WhereUniqueInput`));
    const identityFieldOnUniqueWhere = uniqueWhereInputType.getFields()[identityField];

    if ((identityFieldOnUniqueWhere === null || identityFieldOnUniqueWhere === void 0 ? void 0 : identityFieldOnUniqueWhere.type) !== GraphQLString && (identityFieldOnUniqueWhere === null || identityFieldOnUniqueWhere === void 0 ? void 0 : identityFieldOnUniqueWhere.type) !== GraphQLID) {
      throw new Error(`createAuth was called with an identityField of ${identityField} on the list ${listKey} ` + `but that field doesn't allow being searched uniquely with a String or ID. ` + `You should likely add \`isIndexed: 'unique'\` ` + `to the field at ${listKey}.${identityField}`);
    }

    const baseSchema = getBaseAuthSchema({
      identityField,
      listKey,
      secretField,
      gqlNames,
      secretFieldImpl: getSecretFieldImpl(base.schema, listKey, secretField),
      base
    }); // technically this will incorrectly error if someone has a schema extension that adds a field to the list output type
    // and then wants to fetch that field with `sessionData` but it's extremely unlikely someone will do that since if
    // they want to add a GraphQL field, they'll probably use a virtual field

    let ast;
    let query = `query($id: ID!) { ${getGqlNames({
      listKey,
      // this isn't used to get the itemQueryName and we don't know it here
      pluralGraphQLName: ''
    }).itemQueryName}(where: { id: $id }) { ${sessionData} } }`;

    try {
      ast = parse(query);
    } catch (err) {
      throw new Error(`The query to get session data has a syntax error, the sessionData option in your createAuth usage is likely incorrect\n${err}`);
    }

    const errors = validate(base.schema, ast);

    if (errors.length) {
      throw new Error(`The query to get session data has validation errors, the sessionData option in your createAuth usage is likely incorrect\n${errors.join('\n')}`);
    }

    return [baseSchema.extension, initFirstItem && getInitFirstItemSchema({
      listKey,
      fields: initFirstItem.fields,
      itemData: initFirstItem.itemData,
      gqlNames,
      graphQLSchema: base.schema,
      ItemAuthenticationWithPasswordSuccess: baseSchema.ItemAuthenticationWithPasswordSuccess
    }), passwordResetLink && getPasswordResetSchema({
      identityField,
      listKey,
      secretField,
      passwordResetLink,
      gqlNames,
      passwordResetTokenSecretFieldImpl: getSecretFieldImpl(base.schema, listKey, 'passwordResetToken')
    }), magicAuthLink && getMagicAuthLinkSchema({
      identityField,
      listKey,
      magicAuthLink,
      gqlNames,
      magicAuthTokenSecretFieldImpl: getSecretFieldImpl(base.schema, listKey, 'magicAuthToken'),
      base
    })].filter(x => x !== undefined);
  });
};

const signinTemplate = _ref => {
  let {
    gqlNames,
    identityField,
    secretField
  } = _ref;
  // -- TEMPLATE START
  return `import { getSigninPage } from '@keystone-6/auth/pages/SigninPage'

export default getSigninPage(${JSON.stringify({
    identityField: identityField,
    secretField: secretField,
    mutationName: gqlNames.authenticateItemWithPassword,
    successTypename: gqlNames.ItemAuthenticationWithPasswordSuccess,
    failureTypename: gqlNames.ItemAuthenticationWithPasswordFailure
  })});
`; // -- TEMPLATE END
};

const initTemplate = _ref => {
  let {
    listKey,
    initFirstItem
  } = _ref;
  // -- TEMPLATE START
  return `import { getInitPage } from '@keystone-6/auth/pages/InitPage';

const fieldPaths = ${JSON.stringify(initFirstItem.fields)};

export default getInitPage(${JSON.stringify({
    listKey,
    fieldPaths: initFirstItem.fields,
    enableWelcome: !initFirstItem.skipKeystoneWelcome
  })});
`; // -- TEMPLATE END
};

const _excluded = ["get"];
/**
 * createAuth function
 *
 * Generates config for Keystone to implement standard auth features.
 */

function createAuth(_ref) {
  let {
    listKey,
    secretField,
    initFirstItem,
    identityField,
    magicAuthLink,
    passwordResetLink,
    sessionData = 'id'
  } = _ref;
  const gqlNames = {
    // Core
    authenticateItemWithPassword: `authenticate${listKey}WithPassword`,
    ItemAuthenticationWithPasswordResult: `${listKey}AuthenticationWithPasswordResult`,
    ItemAuthenticationWithPasswordSuccess: `${listKey}AuthenticationWithPasswordSuccess`,
    ItemAuthenticationWithPasswordFailure: `${listKey}AuthenticationWithPasswordFailure`,
    // Initial data
    CreateInitialInput: `CreateInitial${listKey}Input`,
    createInitialItem: `createInitial${listKey}`,
    // Password reset
    sendItemPasswordResetLink: `send${listKey}PasswordResetLink`,
    SendItemPasswordResetLinkResult: `Send${listKey}PasswordResetLinkResult`,
    validateItemPasswordResetToken: `validate${listKey}PasswordResetToken`,
    ValidateItemPasswordResetTokenResult: `Validate${listKey}PasswordResetTokenResult`,
    redeemItemPasswordResetToken: `redeem${listKey}PasswordResetToken`,
    RedeemItemPasswordResetTokenResult: `Redeem${listKey}PasswordResetTokenResult`,
    // Magic auth
    sendItemMagicAuthLink: `send${listKey}MagicAuthLink`,
    SendItemMagicAuthLinkResult: `Send${listKey}MagicAuthLinkResult`,
    redeemItemMagicAuthToken: `redeem${listKey}MagicAuthToken`,
    RedeemItemMagicAuthTokenResult: `Redeem${listKey}MagicAuthTokenResult`,
    RedeemItemMagicAuthTokenSuccess: `Redeem${listKey}MagicAuthTokenSuccess`,
    RedeemItemMagicAuthTokenFailure: `Redeem${listKey}MagicAuthTokenFailure`
  };
  /**
   * fields
   *
   * Fields added to the auth list.
   */

  const fieldConfig = {
    access: () => false,
    ui: {
      createView: {
        fieldMode: 'hidden'
      },
      itemView: {
        fieldMode: 'hidden'
      },
      listView: {
        fieldMode: 'hidden'
      }
    }
  }; // These field names have to follow this format so that for e.g
  // validateAuthToken() behaves correctly.

  const tokenFields = tokenType => ({
    [`${tokenType}Token`]: password(_objectSpread({}, fieldConfig)),
    [`${tokenType}IssuedAt`]: timestamp(_objectSpread({}, fieldConfig)),
    [`${tokenType}RedeemedAt`]: timestamp(_objectSpread({}, fieldConfig))
  });

  const fields = _objectSpread(_objectSpread({}, passwordResetLink && tokenFields('passwordReset')), magicAuthLink && tokenFields('magicAuth'));
  /**
   * pageMiddleware
   *
   * Should be added to the ui.pageMiddleware stack.
   *
   * Redirects:
   *  - from the signin or init pages to the index when a valid session is present
   *  - to the init page when initFirstItem is configured, and there are no user in the database
   *  - to the signin page when no valid session is present
   */


  const pageMiddleware = async _ref2 => {
    let {
      context,
      isValidSession
    } = _ref2;
    const {
      req,
      session
    } = context;
    const pathname = url.parse(req.url).pathname;

    if (isValidSession) {
      if (pathname === '/signin' || initFirstItem && pathname === '/init') {
        return {
          kind: 'redirect',
          to: '/'
        };
      }

      return;
    }

    if (!session && initFirstItem) {
      const count = await context.sudo().query[listKey].count({});

      if (count === 0) {
        if (pathname !== '/init') {
          return {
            kind: 'redirect',
            to: '/init'
          };
        }

        return;
      }
    }

    if (!session && pathname !== '/signin') {
      let to = pathname === '/' ? '/signin' : `/signin?from=${encodeURIComponent(req.url)}`;
      return {
        kind: 'redirect',
        to
      };
    }
  };
  /**
   * getAdditionalFiles
   *
   * This function adds files to be generated into the Admin UI build. Must be added to the
   * ui.getAdditionalFiles config.
   *
   * The signin page is always included, and the init page is included when initFirstItem is set
   */


  const getAdditionalFiles = () => {
    let filesToWrite = [{
      mode: 'write',
      src: signinTemplate({
        gqlNames,
        identityField,
        secretField
      }),
      outputPath: 'pages/signin.js'
    }];

    if (initFirstItem) {
      filesToWrite.push({
        mode: 'write',
        src: initTemplate({
          listKey,
          initFirstItem
        }),
        outputPath: 'pages/init.js'
      });
    }

    return filesToWrite;
  };
  /**
   * publicAuthPages
   *
   * Must be added to the ui.publicPages config
   */


  const publicPages = ['/signin'];

  if (initFirstItem) {
    publicPages.push('/init');
  }
  /**
   * extendGraphqlSchema
   *
   * Must be added to the extendGraphqlSchema config. Can be composed.
   */


  const extendGraphqlSchema = getSchemaExtension({
    identityField,
    listKey,
    secretField,
    gqlNames,
    initFirstItem,
    passwordResetLink,
    magicAuthLink,
    sessionData
  });
  /**
   * validateConfig
   *
   * Validates the provided auth config; optional step when integrating auth
   */

  const validateConfig = keystoneConfig => {
    const listConfig = keystoneConfig.lists[listKey];

    if (listConfig === undefined) {
      const msg = `A createAuth() invocation specifies the list "${listKey}" but no list with that key has been defined.`;
      throw new Error(msg);
    } // TODO: Check for String-like typing for identityField? How?
    // TODO: Validate that the identifyField is unique.
    // TODO: If this field isn't required, what happens if I try to log in as `null`?


    const identityFieldConfig = listConfig.fields[identityField];

    if (identityFieldConfig === undefined) {
      const i = JSON.stringify(identityField);
      const msg = `A createAuth() invocation for the "${listKey}" list specifies ${i} as its identityField but no field with that key exists on the list.`;
      throw new Error(msg);
    } // TODO: We could make the secret field optional to disable the standard id/secret auth and password resets (ie. magic links only)


    const secretFieldConfig = listConfig.fields[secretField];

    if (secretFieldConfig === undefined) {
      const s = JSON.stringify(secretField);
      const msg = `A createAuth() invocation for the "${listKey}" list specifies ${s} as its secretField but no field with that key exists on the list.`;
      throw new Error(msg);
    } // TODO: Could also validate initFirstItem.itemData keys?


    for (const field of (initFirstItem === null || initFirstItem === void 0 ? void 0 : initFirstItem.fields) || []) {
      if (listConfig.fields[field] === undefined) {
        const f = JSON.stringify(field);
        const msg = `A createAuth() invocation for the "${listKey}" list specifies the field ${f} in initFirstItem.fields array but no field with that key exist on the list.`;
        throw new Error(msg);
      }
    }
  };
  /**
   * withItemData
   *
   * Automatically injects a session.data value with the authenticated item
   */

  /* TODO:
    - [ ] We could support additional where input to validate item sessions (e.g an isEnabled boolean)
  */


  const withItemData = _sessionStrategy => {
    const {
      get
    } = _sessionStrategy,
          sessionStrategy = _objectWithoutProperties(_sessionStrategy, _excluded);

    return _objectSpread(_objectSpread({}, sessionStrategy), {}, {
      get: async _ref3 => {
        let {
          req,
          createContext
        } = _ref3;
        const session = await get({
          req,
          createContext
        });
        const sudoContext = createContext({
          sudo: true
        });

        if (!session || !session.listKey || session.listKey !== listKey || !session.itemId || !sudoContext.query[session.listKey]) {
          return;
        }

        try {
          const data = await sudoContext.query[listKey].findOne({
            where: {
              id: session.itemId
            },
            query: sessionData
          });
          if (!data) return;
          return _objectSpread(_objectSpread({}, session), {}, {
            itemId: session.itemId,
            listKey,
            data
          });
        } catch (e) {
          // TODO: the assumption is this should only be from an invalid sessionData configuration
          //   it could be something else though, either way, result is a bad session
          return;
        }
      }
    });
  };
  /**
   * withAuth
   *
   * Automatically extends config with the correct auth functionality. This is the easiest way to
   * configure auth for keystone; you should probably use it unless you want to extend or replace
   * the way auth is set up with custom functionality.
   *
   * It validates the auth config against the provided keystone config, and preserves existing
   * config by composing existing extendGraphqlSchema functions and ui config.
   */


  const withAuth = keystoneConfig => {
    var _keystoneConfig$ui;

    validateConfig(keystoneConfig);
    let ui = keystoneConfig.ui;

    if (!((_keystoneConfig$ui = keystoneConfig.ui) !== null && _keystoneConfig$ui !== void 0 && _keystoneConfig$ui.isDisabled)) {
      var _keystoneConfig$ui2, _keystoneConfig$ui3;

      ui = _objectSpread(_objectSpread({}, keystoneConfig.ui), {}, {
        publicPages: [...(((_keystoneConfig$ui2 = keystoneConfig.ui) === null || _keystoneConfig$ui2 === void 0 ? void 0 : _keystoneConfig$ui2.publicPages) || []), ...publicPages],
        getAdditionalFiles: [...(((_keystoneConfig$ui3 = keystoneConfig.ui) === null || _keystoneConfig$ui3 === void 0 ? void 0 : _keystoneConfig$ui3.getAdditionalFiles) || []), getAdditionalFiles],
        pageMiddleware: async args => {
          var _await$pageMiddleware, _keystoneConfig$ui4, _keystoneConfig$ui4$p;

          return (_await$pageMiddleware = await pageMiddleware(args)) !== null && _await$pageMiddleware !== void 0 ? _await$pageMiddleware : keystoneConfig === null || keystoneConfig === void 0 ? void 0 : (_keystoneConfig$ui4 = keystoneConfig.ui) === null || _keystoneConfig$ui4 === void 0 ? void 0 : (_keystoneConfig$ui4$p = _keystoneConfig$ui4.pageMiddleware) === null || _keystoneConfig$ui4$p === void 0 ? void 0 : _keystoneConfig$ui4$p.call(_keystoneConfig$ui4, args);
        },
        enableSessionItem: true,
        isAccessAllowed: async context => {
          var _context$req, _keystoneConfig$ui5;

          // Allow access to the adminMeta data from the /init path to correctly render that page
          // even if the user isn't logged in (which should always be the case if they're seeing /init)
          const headers = (_context$req = context.req) === null || _context$req === void 0 ? void 0 : _context$req.headers;
          const host = headers ? headers['x-forwarded-host'] || headers['host'] : null;
          const url = headers !== null && headers !== void 0 && headers.referer ? new URL(headers.referer) : undefined;
          const accessingInitPage = (url === null || url === void 0 ? void 0 : url.pathname) === '/init' && (url === null || url === void 0 ? void 0 : url.host) === host && (await context.sudo().query[listKey].count({})) === 0;
          return accessingInitPage || ((_keystoneConfig$ui5 = keystoneConfig.ui) !== null && _keystoneConfig$ui5 !== void 0 && _keystoneConfig$ui5.isAccessAllowed ? keystoneConfig.ui.isAccessAllowed(context) : context.session !== undefined);
        }
      });
    }

    if (!keystoneConfig.session) throw new TypeError('Missing .session configuration');
    const session = withItemData(keystoneConfig.session);
    const existingExtendGraphQLSchema = keystoneConfig.extendGraphqlSchema;
    const listConfig = keystoneConfig.lists[listKey];
    return _objectSpread(_objectSpread({}, keystoneConfig), {}, {
      ui,
      session,
      // Add the additional fields to the references lists fields object
      // TODO: The fields we're adding here shouldn't naively replace existing fields with the same key
      // Leaving existing fields in place would allow solution devs to customise these field defs (eg. access control,
      // work factor for the tokens, etc.) without abandoning the withAuth() interface
      lists: _objectSpread(_objectSpread({}, keystoneConfig.lists), {}, {
        [listKey]: _objectSpread(_objectSpread({}, listConfig), {}, {
          fields: _objectSpread(_objectSpread({}, listConfig.fields), fields)
        })
      }),
      extendGraphqlSchema: existingExtendGraphQLSchema ? schema => existingExtendGraphQLSchema(extendGraphqlSchema(schema)) : extendGraphqlSchema
    });
  };

  return {
    withAuth // In the future we may want to return the following so that developers can
    // roll their own. This is pending a review of the use cases this might be
    // appropriate for, along with documentation and testing.
    // ui: { enableSessionItem: true, pageMiddleware, getAdditionalFiles, publicPages },
    // fields,
    // extendGraphqlSchema,
    // validateConfig,

  };
}

export { createAuth };
